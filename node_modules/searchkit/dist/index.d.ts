import * as _elastic_elasticsearch_lib_api_types from '@elastic/elasticsearch/lib/api/types';
import { SearchHit, SearchResponseBody, QueryDslQueryContainer, KnnQuery, SearchRequest as SearchRequest$1, AggregationsAggregationContainer } from '@elastic/elasticsearch/lib/api/types';
export { SearchRequest as ElasticsearchSearchRequest } from '@elastic/elasticsearch/lib/api/types';
import { MultipleQueriesQuery as MultipleQueriesQuery$1 } from '@algolia/client-search';
export { MultipleQueriesQuery as AlgoliaMultipleQueriesQuery } from '@algolia/client-search';

type ElasticsearchHitDocument = Record<string, unknown>;
type ElasticsearchHit = SearchHit<ElasticsearchHitDocument>;
type ElasticsearchResponseBody = SearchResponseBody<ElasticsearchHitDocument>;
type ElasticsearchQuery = QueryDslQueryContainer;
type ElasticsearchAggregation = AggregationsAggregationContainer;
type KnnSearchQuery = KnnQuery;
type MultipleQueriesQuery = MultipleQueriesQuery$1;
type FacetFieldConfig = {
    attribute: string;
    field: string;
    type: 'numeric' | 'string' | 'date';
    nestedPath?: string;
    facetQuery?: (field: string, size: number, search: string) => ElasticsearchAggregation;
    filterQuery?: (field: string, value: string) => ElasticsearchQuery;
};
type FilterAttribute = {
    attribute: string;
    field: string;
    type: 'numeric' | 'string' | 'date';
    nestedPath?: string;
    filterQuery?: (field: string, value: string) => ElasticsearchQuery;
};
interface BasicAuth {
    username: string;
    password: string;
}
interface ConfigConnection {
    /**
     * @description The Elasticsearch host
     * @example https://my-elasticsearch-host.com
     */
    host: string;
    /**
     * @description The Elasticsearch API key. This is optional and only required if you have API key authentication enabled.
     * @example 1234567890
     */
    apiKey?: string;
    /**
     * @description Headers to be sent with the Elasticsearch request.
     * @example { 'X-My-Header': 'My-Value' }
     */
    headers?: Record<string, string>;
    /**
     * @description The Elasticsearch account. This is optional and only required if you have basic authentication enabled.
     * @example username: elastic
     * @example password: changeme
     */
    auth?: BasicAuth;
}
interface SearchAttributeConfig {
    field: string;
    weight?: number;
}
type FacetAttribute = string | FacetFieldConfig;
type SearchAttribute = string | SearchAttributeConfig;
type SortingOption = {
    field: string;
    order: 'asc' | 'desc';
};
interface SearchSettingsConfig {
    /**
     * @description fields that will be searched when a user enters a query
     */
    search_attributes: SearchAttribute[];
    /**
     * @description fields that will be used to as facets
     */
    facet_attributes?: FacetAttribute[];
    /**
     * @description fields that will be used to as filters
     */
    filter_attributes?: FilterAttribute[];
    /**
     * @description fields that will be returned in the search results
     * @example ['name', 'price']
     **/
    result_attributes: string[];
    /**
     * @description fields that can be used to highlight search terms in the search results
     * @example ['name']
     **/
    highlight_attributes?: string[];
    /**
     * @description fields that can be used to generate a snippet of text matches from the search results
     * @example ['description']
     **/
    snippet_attributes?: string[];
    /**
     * @description Rules that can customise search results order.
     */
    query_rules?: QueryRule[];
    /**
     * @description Sorting options for the search. This is optional and will default to sorting by _score if not provided.
     * @example { 'price': { field: 'price', order: 'asc' } }
     * @example { 'price': [{ field: 'price', order: 'asc' }, { field: 'name', order: 'asc' }] }
     */
    sorting?: Record<string, SortingOption | SortingOption[]>;
    /**
     * @description The attribute that will be used for geo search. This is required if you want to use geo search. Must be am Elasticsearch geo_point type field.
     */
    geo_attribute?: string;
}
interface QueryStringRuleCondition {
    context: 'query';
    match_type: 'prefix' | 'contains' | 'exact';
    value: string;
}
interface ContextRuleCondition {
    context: 'context';
    value: string[];
}
interface FilterRuleCondition {
    context: 'filterPresent';
    values: {
        attribute: string;
        value: string;
    }[];
}
interface PinnedResultAction {
    action: 'PinnedResult';
    documentIds: string[];
}
interface QueryBoostAction {
    action: 'QueryBoost';
    query: string;
    weight: number;
}
interface FilterAction {
    action: 'QueryFilter';
    query: string;
}
interface QueryRewriteAction {
    action: 'QueryRewrite';
    query: string;
}
interface RenderUserDataAction {
    action: 'RenderUserData';
    userData: string;
}
interface RenderFacetsOrderAction {
    action: 'RenderFacetsOrder';
    facetAttributesOrder: string[];
}
type QueryRuleAction = PinnedResultAction | QueryBoostAction | QueryRewriteAction | RenderUserDataAction | RenderFacetsOrderAction | FilterAction;
type QueryRuleCondition = QueryStringRuleCondition | ContextRuleCondition | FilterRuleCondition;
interface QueryRule {
    id: string;
    conditions: QueryRuleCondition[][];
    actions: QueryRuleAction[];
}
interface SearchkitConfig {
    connection: ConfigConnection | Transporter;
    search_settings: SearchSettingsConfig;
}
type SearchRequest = {
    body: SearchRequest$1;
    request: MultipleQueriesQuery$1;
    indexName: string;
};
interface RequestOptions {
    /**
     * @description Allows you to override the organic query
     * @param query The original query search terms
     * @param search_attributes The search attributes configured in the search settings
     * @param config The search settings
     * @returns An Elasticsearch query object or an array of Elasticsearch query objects
     * @returns false if you want to skip the search query (useful for just KNN search)
     */
    getQuery?: (query: string, search_attributes: SearchAttribute[], config: SearchSettingsConfig) => ElasticsearchQuery | ElasticsearchQuery[] | false;
    /**
     * @description Allows you to add base filters to be applied to the search. This is useful for user / document level permissions
     * @returns An array of Elasticsearch query objects that will be wrapped in a bool filter query
     **/
    getBaseFilters?: () => ElasticsearchQuery[];
    /**
     * @description Allows you to specify the KNN query to be used for KNN search. Hits will be combined with the organic query. If you do not want to use the organic query, return false from getQuery.
     * @param query The original query search terms
     * @param search_attributes The search attributes configured in the search settings
     * @param config The search settings
     * @returns An Elasticsearch KNN Search Query
     */
    getKnnQuery?: (query: string, search_attributes: SearchAttribute[], config: SearchSettingsConfig) => KnnQuery;
    /**
     * @description Hooks are escape hatches that allow you to modify the search requests to Elasticsearch and the responses back from Elasticsearch.
     **/
    hooks?: {
        /**
         * @description Allows you to modify the search requests before they are sent to Elasticsearch
         * @param requests An array of SearchRequest objects, each containing the body (elasticsearch query) and indexName of the request
         * @returns An array of modified SearchRequest objects, each containing the body (elasticsearch query) and indexName of the request
         */
        beforeSearch?: (requests: SearchRequest[]) => Promise<SearchRequest[]>;
        /**
         * @description Allows you to modify the search responses before its transformed into an InstantSearch response
         * @param requests An array of SearchRequest objects, each containing the body (elasticsearch query) and indexName of the request
         * @param responses An array of Elasticsearch Response objects
         * @returns An array of modified Elasticsearch response objects
         */
        afterSearch?: (requests: SearchRequest[], responses: ElasticsearchResponseBody[]) => Promise<ElasticsearchResponseBody[]>;
    };
}
interface Transporter {
    config?: ConfigConnection;
    msearch: (requests: SearchRequest[]) => Promise<ElasticsearchResponseBody[]>;
}
interface AppSettings {
    debug: boolean;
}

declare class ESTransporter implements Transporter {
    config: ConfigConnection;
    private settings;
    constructor(config: ConfigConnection, settings: AppSettings);
    createElasticsearchQueryFromRequest(requests: SearchRequest[]): string;
    performNetworkRequest(requests: SearchRequest[]): Promise<Response>;
    msearch(requests: SearchRequest[]): Promise<ElasticsearchResponseBody[]>;
}

declare const TermFilter: (field: string, value: string) => {
    term: {
        [x: string]: string;
    };
};
declare const MatchFilter: (field: string, value: string) => {
    match: {
        [x: string]: string;
    };
};

declare class Searchkit {
    private config;
    private settings;
    private transporter;
    constructor(config: SearchkitConfig, settings?: AppSettings);
    private performSearch;
    handleInstantSearchRequests(instantsearchRequests: readonly MultipleQueriesQuery$1[], requestOptions?: RequestOptions): Promise<{
        results: ({
            facetHits: any;
            exhaustiveFacetsCount: boolean;
            processingTimeMS: number;
        } | {
            userData?: unknown[] | undefined;
            hits: {
                _geoloc?: {
                    lat: number;
                    lng: number;
                } | null | undefined;
                _snippetResult?: Record<string, any> | undefined;
                _highlightResult?: Record<string, any> | undefined;
                inner_hits?: Record<string, _elastic_elasticsearch_lib_api_types.SearchInnerHitsResult> | undefined;
                objectID: string;
                _index: string;
            }[];
            index: string;
            params: string;
            renderingContent: {
                facetOrdering: {
                    facets: {
                        order: string[];
                    };
                    values: Record<string, {
                        sortRemainingBy: "count";
                    }> | undefined;
                };
            };
            hitsPerPage: number;
            processingTimeMS: number;
            nbHits: number | undefined;
            page: number;
            nbPages: number;
            query: string;
            appliedRules: string[];
            exhaustiveNbHits: boolean;
            exhaustiveFacetsCount: boolean;
            exhaustiveTypo: boolean;
            exhaustive: {
                facetsCount: boolean;
                nbHits: boolean;
                typo: boolean;
            };
        })[];
    }>;
}

export { AppSettings, BasicAuth, ConfigConnection, ESTransporter, ElasticsearchHit, ElasticsearchQuery, ElasticsearchResponseBody, FacetAttribute, FacetFieldConfig, FilterAttribute, KnnSearchQuery, MatchFilter, MultipleQueriesQuery, QueryRule, QueryRuleAction, QueryRuleCondition, RequestOptions, SearchAttribute, SearchAttributeConfig, SearchRequest, SearchSettingsConfig, SearchkitConfig, SortingOption, TermFilter, Transporter, Searchkit as default };
