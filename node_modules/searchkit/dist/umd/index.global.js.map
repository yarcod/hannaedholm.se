{"version":3,"sources":["../../../../node_modules/deepmerge/dist/cjs.js","../../src/index.ts","../../src/transformRequest.ts","../../src/filterUtils.ts","../../src/utils.ts","../../src/filters.ts","../../src/sorting.ts","../../src/highlightUtils.ts","../../src/transformResponse.ts","../../src/Transporter.ts","../../src/queryRules.ts"],"sourcesContent":["'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","import type { MultipleQueriesQuery as AlgoliaMultipleQueriesQuery } from '@algolia/client-search'\nimport { transformRequest } from './transformRequest'\nimport transformResponse, { transformFacetValuesResponse } from './transformResponse'\nimport { SearchkitConfig, SearchRequest, RequestOptions, Transporter, AppSettings } from './types'\nimport { ESTransporter } from './Transporter'\nimport { getQueryRulesActionsFromRequest, QueryRuleActions } from './queryRules'\nimport { createElasticsearchQueryFromRequest } from './utils'\nimport { getIndexName } from './sorting'\nexport * from './types'\nexport * from './Transporter'\nexport * from './filterUtils'\n\nexport default class Searchkit {\n  private transporter: Transporter\n\n  constructor(private config: SearchkitConfig, private settings: AppSettings = { debug: false }) {\n    this.transporter =\n      'msearch' in config.connection\n        ? config.connection\n        : new ESTransporter(config.connection, settings)\n  }\n\n  private async performSearch(requests: SearchRequest[]) {\n    try {\n      if (this.settings.debug) {\n        console.log('Performing search with requests:')\n        console.log('POST /_msearch')\n        console.log(createElasticsearchQueryFromRequest(requests))\n      }\n      const responses = await this.transporter.msearch(requests)\n      return responses\n    } catch (err) {\n      console.error(err)\n      return []\n    }\n  }\n\n  async handleInstantSearchRequests(\n    instantsearchRequests: readonly AlgoliaMultipleQueriesQuery[],\n    requestOptions?: RequestOptions\n  ) {\n    const queryRules = this.config.search_settings.query_rules || []\n\n    const requestQueryRuleActions: QueryRuleActions[] = instantsearchRequests.map((request) => {\n      return getQueryRulesActionsFromRequest(queryRules, request, this.config.search_settings)\n    })\n\n    let esRequests: SearchRequest[] = instantsearchRequests.map((request, i) => ({\n      body: transformRequest(\n        request,\n        this.config.search_settings,\n        requestQueryRuleActions[i],\n        requestOptions\n      ),\n      request: request,\n      indexName: getIndexName(request.indexName, this.config.search_settings)\n    }))\n\n    if (requestOptions?.hooks?.beforeSearch) {\n      esRequests = await requestOptions.hooks.beforeSearch(esRequests)\n    }\n\n    let esResponses = await this.performSearch(esRequests)\n\n    if (requestOptions?.hooks?.afterSearch) {\n      esResponses = await requestOptions.hooks.afterSearch(esRequests, esResponses)\n    }\n\n    const instantsearchResponses = esResponses.map((response, i) => {\n      // @ts-ignore\n      if (instantsearchRequests[i].params?.facetName) {\n        return transformFacetValuesResponse(response, instantsearchRequests[i])\n      }\n      return transformResponse(\n        response,\n        instantsearchRequests[i],\n        this.config.search_settings,\n        requestQueryRuleActions[i]\n      )\n    })\n\n    return {\n      results: instantsearchResponses\n    }\n  }\n}\n","import { QueryDslQueryContainer } from '@elastic/elasticsearch/lib/api/types'\nimport deepmerge from 'deepmerge'\nimport {\n  transformBaseFilters,\n  transformFacetFilters,\n  transformGeoFilters,\n  transformNumericFilters\n} from './filters'\nimport { QueryRuleActions } from './queryRules'\nimport { getSorting } from './sorting'\nimport {\n  FacetAttribute,\n  KnnSearchQuery,\n  RequestOptions,\n  SearchAttribute,\n  SearchSettingsConfig\n} from './types'\nimport { AlgoliaMultipleQueriesQuery, ElasticsearchSearchRequest } from './types'\nimport { getFacet, isNestedFacet } from './utils'\n\nexport const createRegexQuery = (queryString: string) => {\n  let query = queryString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n  query = query\n    .split('')\n    .map((char) => {\n      if (/[a-z]/.test(char)) {\n        return `[${char}${char.toUpperCase()}]`\n      }\n      return char\n    })\n    .join('')\n  query = `${query}.*`\n  if (queryString.length > 2) {\n    query = `([a-zA-Z]+ )+?${query}`\n  }\n  return query\n}\n\nconst TermAggregation = (field: string, size: number, search: string) => {\n  const searchInclude = search && search.length > 0 ? { include: createRegexQuery(search) } : {}\n  return {\n    terms: {\n      field,\n      size,\n      ...searchInclude\n    }\n  }\n}\n\nconst getTermAggregation = (facet: FacetAttribute, size: number, search: string) => {\n  let aggEntries = {}\n  const AggregationFn =\n    typeof facet !== 'string' && facet.facetQuery ? facet.facetQuery : TermAggregation\n\n  const getInnerAggs = (facetName: string, field: string): any => {\n    if (typeof facet === 'string' || facet.type === 'string') {\n      aggEntries = {\n        [facetName]: AggregationFn(field, size, search)\n      }\n    } else if (facet.type === 'numeric') {\n      aggEntries = {\n        [facetName + '$_stats']: {\n          stats: {\n            field: field\n          }\n        },\n        [facetName + '$_entries']: AggregationFn(field, size, search)\n      }\n    }\n    return aggEntries\n  }\n\n  if (typeof facet === 'string') {\n    return getInnerAggs(facet, facet)\n  } else if (isNestedFacet(facet)) {\n    return {\n      [`${facet.nestedPath}.`]: {\n        nested: {\n          path: facet.nestedPath\n        },\n        aggs: getInnerAggs(facet.attribute, `${facet.nestedPath}.${facet.field}`)\n      }\n    }\n  } else {\n    return getInnerAggs(facet.attribute, facet.field)\n  }\n}\n\nexport const getAggs = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions\n) => {\n  const { params = {}, type } = request\n  // @ts-ignore\n  const { facets, maxValuesPerFacet, facetName, facetQuery } = params\n  const maxFacetSize = maxValuesPerFacet || 10\n  const facetAttributes = config.facet_attributes || []\n\n  if (facetName) {\n    const facet = getFacet(facetAttributes, facetName)\n    if (!facet) return null\n    return getTermAggregation(facet, maxFacetSize, facetQuery)\n  } else if (Array.isArray(facets)) {\n    let facetAttibutes = config.facet_attributes || []\n\n    if (queryRuleActions.facetAttributesOrder) {\n      facetAttibutes = queryRuleActions.facetAttributesOrder\n        .map((attribute) => {\n          return getFacet(config.facet_attributes || [], attribute)\n        })\n        .filter((x): x is FacetAttribute => x !== null)\n    }\n\n    const facetAttributes: FacetAttribute[] =\n      facets[0] === '*'\n        ? facetAttibutes\n        : facets\n            .map((facetAttribute) => {\n              return getFacet(config.facet_attributes || [], facetAttribute)\n            })\n            .filter((x): x is FacetAttribute => x !== null)\n\n    return (\n      facetAttributes.reduce((sum, facet) => {\n        return deepmerge(sum, getTermAggregation(facet, maxFacetSize, ''))\n      }, {}) || {}\n    )\n  } else if (typeof facets === 'string') {\n    const field = getFacet(config.facet_attributes || [], facets)\n    if (!field) return {}\n    return getTermAggregation(field, maxFacetSize, '')\n  }\n}\n\nfunction queryRulesWrapper(organicQuery: any, queryRuleActions: QueryRuleActions) {\n  if (queryRuleActions.touched) {\n    return {\n      function_score: {\n        query: {\n          pinned: {\n            ids: queryRuleActions.pinnedDocs,\n            organic: organicQuery\n          }\n        },\n        functions: queryRuleActions.boostFunctions\n      }\n    }\n  }\n  return organicQuery\n}\n\nexport function RelevanceQueryMatch(query: string, search_attributes: SearchAttribute[]) {\n  const getFieldsMap = (boostMultiplier: number) => {\n    return search_attributes.map((attribute) => {\n      return typeof attribute === 'string'\n        ? attribute\n        : `${attribute.field}^${(attribute.weight || 1) * boostMultiplier}`\n    })\n  }\n\n  return {\n    bool: {\n      should: [\n        {\n          bool: {\n            should: [\n              {\n                multi_match: {\n                  query: query,\n                  fields: getFieldsMap(1),\n                  fuzziness: 'AUTO:4,8'\n                }\n              },\n              {\n                multi_match: {\n                  query: query,\n                  fields: getFieldsMap(0.5),\n                  type: 'bool_prefix'\n                }\n              }\n            ]\n          }\n        },\n        {\n          multi_match: {\n            query: query,\n            type: 'phrase',\n            fields: getFieldsMap(2)\n          }\n        }\n      ]\n    }\n  }\n}\n\nconst getQuery = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions,\n  requestOptions?: RequestOptions\n): { query?: QueryDslQueryContainer; knn?: KnnSearchQuery } => {\n  const query = queryRuleActions.query\n\n  const searchAttributes = config.search_attributes\n\n  const filters = [\n    ...transformFacetFilters(request, config),\n    ...transformNumericFilters(request, config),\n    ...transformBaseFilters(request, config),\n    ...transformGeoFilters(request, config),\n    ...(requestOptions?.getBaseFilters?.() || []),\n    ...queryRuleActions.baseFilters\n  ]\n\n  let organicQuery =\n    typeof query === 'string' && query !== ''\n      ? requestOptions?.getQuery\n        ? requestOptions.getQuery(query, searchAttributes, config)\n        : RelevanceQueryMatch(query, searchAttributes)\n      : {\n          match_all: {}\n        }\n\n  const hasKnn = typeof requestOptions?.getKnnQuery === 'function'\n  const hasNoQuery = requestOptions?.getQuery?.(query, searchAttributes, config) === false\n\n  if (hasNoQuery || (hasKnn && query === '')) {\n    organicQuery = {\n      match_all: {}\n    }\n  }\n\n  const queryDsl = {\n    bool: {\n      filter: filters,\n      must: queryRuleActions.touched\n        ? queryRulesWrapper(organicQuery, queryRuleActions)\n        : organicQuery\n    }\n  }\n\n  let knnQueryDsl: KnnSearchQuery | null = null\n\n  if (hasKnn && query !== '') {\n    knnQueryDsl = {\n      filter: filters,\n      ...(requestOptions?.getKnnQuery?.(query, searchAttributes, config) || {})\n    } as KnnSearchQuery\n  }\n\n  if (query !== '' && hasNoQuery && hasKnn && knnQueryDsl) {\n    return {\n      knn: knnQueryDsl\n    }\n  }\n\n  return {\n    query: queryDsl,\n    knn: knnQueryDsl ? knnQueryDsl : undefined\n  }\n}\n\nconst getResultsSize = (request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) => {\n  const { params = {} } = request\n  const hitsPerPage = params.hitsPerPage == null ? 20 : params.hitsPerPage\n\n  return {\n    size: hitsPerPage,\n    from: (params.page || 0) * hitsPerPage\n  }\n}\n\nexport const getHitFields = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { attributesToRetrieve } = params\n  // ignoring attributesToRetrieve for now\n\n  const sourceFields = new Set([\n    ...(config.result_attributes || []),\n    ...(config.highlight_attributes || []),\n    ...(config.geo_attribute ? [config.geo_attribute] : [])\n  ])\n\n  return {\n    _source: {\n      includes: Array.from(sourceFields)\n    }\n  }\n}\n\nexport const getSnippetFieldLength = (attribute: string) => {\n  const defaultMatch = {\n    attribute,\n    length: 100\n  }\n  if (!attribute.includes(':')) {\n    return defaultMatch\n  }\n  const match = attribute.match(/(.+)\\:(\\d+)/)\n  if (!match) return defaultMatch\n  return {\n    attribute: match[1],\n    length: parseInt(match[2])\n  }\n}\n\nexport const getHighlightFields = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { attributesToHighlight } = params\n  // ignoring attributesToHighlight for now\n\n  const highlightFields =\n    config.highlight_attributes?.reduce(\n      (sum, field) => ({\n        ...sum,\n        [field]: {\n          number_of_fragments: 0\n        }\n      }),\n      {}\n    ) || {}\n\n  const snippetFields =\n    config.snippet_attributes?.reduce(\n      (sum, attribute) => ({\n        ...sum,\n        [getSnippetFieldLength(attribute).attribute]: {\n          number_of_fragments: 5,\n          fragment_size: getSnippetFieldLength(attribute).length\n        }\n      }),\n      {}\n    ) || {}\n\n  return {\n    highlight: {\n      pre_tags: ['<em>'],\n      post_tags: ['</em>'],\n      fields: {\n        ...highlightFields,\n        ...snippetFields\n      }\n    }\n  }\n}\n\nexport function transformRequest(\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions,\n  requestOptions?: RequestOptions\n): ElasticsearchSearchRequest {\n  const body: ElasticsearchSearchRequest = {\n    aggs: getAggs(request, config, queryRuleActions),\n    ...getQuery(request, config, queryRuleActions, requestOptions),\n    ...getResultsSize(request, config),\n    ...getHitFields(request, config),\n    ...getHighlightFields(request, config),\n    ...getSorting(request, config)\n  }\n\n  return body\n}\n","export const TermFilter = (field: string, value: string) => {\n  return { term: { [field]: value } }\n}\n\nexport const MatchFilter = (field: string, value: string) => {\n  return { match: { [field]: value } }\n}\n","import { FacetAttribute, FacetFieldConfig, SearchRequest } from './types'\n\nexport const createRegexQuery = (queryString: string) => {\n  let query = queryString.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&')\n  query = query\n    .split('')\n    .map((char) => {\n      if (/[a-z]/.test(char)) {\n        return `[${char}${char.toUpperCase()}]`\n      }\n      return char\n    })\n    .join('')\n  query = `${query}.*`\n  if (queryString.length > 2) {\n    query = `([a-zA-Z]+ )+?${query}`\n  }\n  return query\n}\n\nexport const getFacet = (\n  facet_attributes: FacetAttribute[],\n  attributeName: string\n): FacetAttribute | null => {\n  const f = facet_attributes.find((a) => {\n    if (typeof a === 'string') {\n      return a === attributeName\n    }\n    return a.attribute === attributeName\n  })\n  return f || null\n}\n\nexport const isNestedFacet = (facet: FacetAttribute): boolean => {\n  return typeof facet !== 'string' && !!facet.nestedPath\n}\n\nexport const getFacetField = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): string => {\n  const attributeKey = typeof attribute === 'string' ? attribute : attribute.attribute\n\n  if (facet_attributes.includes(attributeKey)) {\n    return attributeKey\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a.attribute === attributeKey)?.field || attributeKey\n  )\n}\n\nexport const getFacetByAttribute = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): string => {\n  const attributeKey = getFacetAttribute(attribute)\n\n  if (facet_attributes.includes(attributeKey)) {\n    return attributeKey\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a.attribute === attributeKey)?.attribute || attributeKey\n  )\n}\n\nexport const getFacetAttribute = (facetAttribute: FacetAttribute): string => {\n  return typeof facetAttribute === 'string' ? facetAttribute : facetAttribute.attribute\n}\n\nexport const getFacetFieldType = (\n  facet_attributes: FacetAttribute[],\n  attribute: FacetAttribute\n): FacetFieldConfig['type'] => {\n  const attributeKey = typeof attribute === 'string' ? attribute : attribute.attribute\n\n  if (facet_attributes.includes(attributeKey)) {\n    return 'string'\n  }\n  return (\n    facet_attributes\n      // @ts-ignore: object is possibly null\n      .find((a) => a?.attribute === attributeKey)?.type || 'string'\n  )\n}\n\nexport const createElasticsearchQueryFromRequest = (requests: SearchRequest[]) => {\n  return requests\n    .reduce<string[]>(\n      (sum, request) => [\n        ...sum,\n        JSON.stringify({ index: request.indexName }),\n        '\\n',\n        JSON.stringify(request.body),\n        '\\n'\n      ],\n      []\n    )\n    .join('')\n}\n","import { MatchFilter, TermFilter } from './filterUtils'\nimport type {\n  AlgoliaMultipleQueriesQuery,\n  FacetAttribute,\n  SearchSettingsConfig,\n  ElasticsearchQuery,\n  FilterAttribute,\n  FacetFieldConfig\n} from './types'\nimport { getFacet, getFacetAttribute, isNestedFacet } from './utils'\n\nexport const transformNumericFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n): ElasticsearchQuery[] => {\n  const { params = {} } = request\n  const { numericFilters } = params\n\n  if (!Array.isArray(numericFilters)) {\n    return []\n  }\n\n  return numericFilters.reduce((sum, filter: string) => {\n    let match, field, operator, value, maxValue = ''\n    let groups = filter.match(\n      /([\\w\\.\\_\\-]+)\\s*(\\=|\\!\\=|\\>|\\>\\=|\\<|\\<\\=)\\s*(-?\\d+)/\n    )\n\n    if (groups) {\n      [match, field, operator, value] = groups\n    }\n    else {\n      // Alternative syntax: 'attribute:lower_value TO higher_value'\n      groups = filter.match(\n        /([\\w\\.\\_\\-]+):\\s*(-?\\d+)\\s*([Tt][Oo])\\s*(-?\\d+)/\n      )\n\n      if (!groups) {\n        throw new Error(\n          `Numeric filter \"${filter}\" could not be parsed. It should either be in the format \"attributeName operator operand\" or \"attributeName: lowerBound TO upperBound\"`\n        );\n      }\n\n      [match, field, value, operator, maxValue] = groups\n    }\n\n    const facetFilterMap = getFacetFilterMap(\n      config.facet_attributes || [],\n      config.filter_attributes || []\n    )\n    const facetFilterConfig = facetFilterMap[field]\n\n    const getFilter = (field: string, operator: string, value: string) => {\n      if (operator === '=') {\n        return {\n          term: {\n            [field]: value\n          }\n        }\n      } else if (operator === '!=') {\n        return {\n          bool: {\n            must_not: {\n              term: {\n                [field]: value\n              }\n            }\n          }\n        }\n      } else if (operator === '>') {\n        return {\n          range: {\n            [field]: {\n              gt: value\n            }\n          }\n        }\n      } else if (operator === '>=') {\n        return {\n          range: {\n            [field]: {\n              gte: value\n            }\n          }\n        }\n      } else if (operator === '<') {\n        return {\n          range: {\n            [field]: {\n              lt: value\n            }\n          }\n        }\n      } else if (operator === '<=') {\n        return {\n          range: {\n            [field]: {\n              lte: value\n            }\n          }\n        }\n      } else if (operator.toUpperCase() === 'TO') {\n        return {\n          range: {\n            [field]: {\n              gte: value,\n              lte: maxValue,\n            }\n          }\n        }\n      }\n    }\n\n    const esFilter = []\n\n    if (facetFilterConfig.nestedPath) {\n      const nestedPathPresent = sum.find((filter: any) => {\n        return filter.nested.path === facetFilterConfig.nestedPath\n      })\n\n      if (nestedPathPresent) {\n        nestedPathPresent.nested.query.bool.filter.push(\n          getFilter(facetFilterConfig.nestedPath + '.' + facetFilterConfig.field, operator, value)\n        )\n      } else {\n        esFilter.push({\n          nested: {\n            path: facetFilterConfig.nestedPath,\n            inner_hits: {},\n            query: {\n              bool: {\n                filter: [\n                  getFilter(\n                    facetFilterConfig.nestedPath + '.' + facetFilterConfig.field,\n                    operator,\n                    value\n                  )\n                ]\n              }\n            }\n          }\n        })\n      }\n    } else {\n      esFilter.push(getFilter(facetFilterConfig.field, operator, value))\n    }\n\n    return [...sum, ...esFilter]\n  }, [])\n}\n\nconst getFacetFilterMap = (facets: FacetAttribute[], filters: FilterAttribute[]) => {\n  return [...filters, ...facets].reduce<Record<string, FacetFieldConfig | FilterAttribute>>(\n    (sum, filter) => {\n      let f: FacetFieldConfig | FilterAttribute =\n        typeof filter === 'string' ? { attribute: filter, field: filter, type: 'string' } : filter\n\n      return {\n        ...sum,\n        [f.attribute]: f\n      }\n    },\n    {}\n  )\n}\n\nexport const transformFacetFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n): ElasticsearchQuery[] => {\n  const { params = {} } = request\n  const { facetFilters } = params\n\n  if (!Array.isArray(facetFilters)) {\n    return []\n  }\n\n  const facetFilterMap = getFacetFilterMap(\n    config.facet_attributes || [],\n    config.filter_attributes || []\n  )\n\n  return facetFilters.reduce((sum, filter) => {\n    if (Array.isArray(filter)) {\n      return [\n        ...sum,\n        {\n          bool: {\n            should: filter.reduce((sum, filter) => {\n              const [facet, value] = filter.split(':')\n              const facetFilterConfig = facetFilterMap[facet]\n              if (!facetFilterConfig)\n                throw new Error(\n                  `Facet \"${facet}\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.`\n                )\n              const field = facetFilterConfig.field\n              const filterClauseFn = facetFilterConfig.filterQuery || TermFilter\n\n              if (isNestedFacet(facetFilterConfig)) {\n                // detect if there is a nested filter in sum\n                // if one doesn't exist, add one\n                // if one does exist, add to it\n                const nestedFilter = sum.find((filter: any) => {\n                  return filter.nested && filter.nested.path === facetFilterConfig.nestedPath\n                })\n\n                if (nestedFilter) {\n                  nestedFilter.nested.query.bool.should.push(\n                    filterClauseFn(\n                      `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                      value\n                    )\n                  )\n                  return sum\n                } else {\n                  return [\n                    ...sum,\n                    {\n                      nested: {\n                        inner_hits: {},\n                        path: facetFilterConfig.nestedPath,\n                        query: {\n                          bool: {\n                            should: [\n                              filterClauseFn(\n                                `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                                value\n                              )\n                            ]\n                          }\n                        }\n                      }\n                    }\n                  ]\n                }\n              }\n              return [...sum, filterClauseFn(field, value)]\n            }, [])\n          }\n        }\n      ]\n    } else if (typeof filter === 'string') {\n      const [facet, value] = filter.split(':')\n\n      const facetFilterConfig = facetFilterMap[facet]\n      if (!facetFilterConfig)\n        throw new Error(\n          `Facet \"${facet}\" not found in configuration. Add configuration to either facet_attributes or filter_attributes.`\n        )\n\n      const filterClauseFn = facetFilterConfig.filterQuery || TermFilter\n\n      if (isNestedFacet(facetFilterConfig) && facetFilterConfig.nestedPath) {\n        // detect if there is a nested filter in sum\n        // if one doesn't exist, add one\n        // if one does exist, add to it\n        const nestedFilter = sum.find((filter: any) => {\n          return filter.nested && filter.nested.path === facetFilterConfig.nestedPath + '.'\n        })\n\n        if (nestedFilter) {\n          nestedFilter.nested.query.bool.should.push(\n            filterClauseFn(`${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`, value)\n          )\n          return sum\n        } else {\n          return [\n            ...sum,\n            {\n              nested: {\n                inner_hits: {},\n                path: facetFilterConfig.nestedPath,\n                query: {\n                  bool: {\n                    should: [\n                      filterClauseFn(\n                        `${facetFilterConfig.nestedPath}.${facetFilterConfig.field}`,\n                        value\n                      )\n                    ]\n                  }\n                }\n              }\n            }\n          ]\n        }\n      }\n      return [...sum, filterClauseFn(facetFilterConfig.field, value)]\n    }\n  }, [])\n}\n\nexport const transformQueryString = (\n  facets: FacetAttribute[] = [],\n  filters: FilterAttribute[] = [],\n  queryString: string\n) => {\n  const regex = /([\\w\\.\\-]+)\\:/gi\n  const filterMap = getFacetFilterMap(facets, filters)\n  return queryString.replace(regex, (match: string, word: string) => {\n    if (!filterMap[word]) {\n      throw new Error(\n        `Attribute \"${word}\" is not defined as an attribute in the facet or filter search settings`\n      )\n    }\n\n    if (!!filterMap[word].nestedPath) {\n      throw new Error(\n        `Attribute \"${word}\" is a nested field and cannot be used as a filter. Nested fields are supported in facetFilers or numericFilters.`\n      )\n    }\n\n    return filterMap[word].field + ':'\n  })\n}\n\nexport const transformBaseFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const { params = {} } = request\n  const { filters } = params\n\n  if (!filters || filters === '') {\n    return []\n  }\n\n  const queryString = transformQueryString(\n    config.facet_attributes,\n    config.filter_attributes,\n    filters\n  )\n\n  return [\n    {\n      query_string: {\n        query: queryString\n      }\n    }\n  ]\n}\n\nexport const transformGeoFilters = (\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  if (!config.geo_attribute) {\n    return []\n  }\n  const { params = {} } = request\n  const { aroundLatLng, aroundRadius, insideBoundingBox } = params\n\n  if (insideBoundingBox) {\n    return [insideBoundingBoxFilter(insideBoundingBox, config.geo_attribute)]\n  }\n\n  if (aroundLatLng) {\n    const geoPoint = aroundLatLng.split(',')\n\n    return [\n      {\n        geo_distance: {\n          distance: aroundRadius || '1000m',\n          [config.geo_attribute]: {\n            lat: geoPoint[0],\n            lon: geoPoint[1]\n          }\n        }\n      }\n    ]\n  }\n\n  return []\n}\n\nfunction insideBoundingBoxFilter(\n  insideBoundingBox: string | readonly (readonly number[])[],\n  field: string\n) {\n  const geoBoundingboxFilter = (top: number, left: number, bottom: number, right: number) => {\n    return {\n      geo_bounding_box: {\n        [field]: {\n          top_right: {\n            lat: top,\n            lon: left\n          },\n          bottom_left: {\n            lat: bottom,\n            lon: right\n          }\n        }\n      }\n    }\n  }\n\n  if (typeof insideBoundingBox === 'string') {\n    const [top, left, bottom, right] = insideBoundingBox.split(',')\n    return geoBoundingboxFilter(\n      parseFloat(top),\n      parseFloat(left),\n      parseFloat(bottom),\n      parseFloat(right)\n    )\n  } else if (Array.isArray(insideBoundingBox)) {\n    const geoBoundingboxes = insideBoundingBox.map((boundingBox) => {\n      const [top, left, bottom, right] = boundingBox\n      return geoBoundingboxFilter(\n        parseFloat(top),\n        parseFloat(left),\n        parseFloat(bottom),\n        parseFloat(right)\n      )\n    })\n\n    return {\n      bool: {\n        should: geoBoundingboxes\n      }\n    }\n  }\n}\n","import { SearchSettingsConfig } from './types'\nimport { AlgoliaMultipleQueriesQuery } from './types'\n\nexport function getSorting(request: AlgoliaMultipleQueriesQuery, config: SearchSettingsConfig) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    const selectedSorting = Object.keys(config.sorting).find((key) => {\n      if (request.indexName.endsWith(key)) {\n        return true\n      }\n    })\n\n    if (!selectedSorting && !config.sorting.default) return {}\n\n    const sortOption = selectedSorting ? config.sorting[selectedSorting] : config.sorting.default\n\n    if (Array.isArray(sortOption)) {\n      return {\n        sort: sortOption.map((sorting) => {\n          return {\n            [sorting.field]: sorting.order\n          }\n        })\n      }\n    } else {\n      return {\n        sort: {\n          [sortOption.field]: sortOption.order\n        }\n      }\n    }\n  }\n  return {}\n}\n\nexport function getIndexName(indexName: string, config: SearchSettingsConfig) {\n  if (config.sorting && Object.keys(config.sorting).length > 0) {\n    const selectedSorting = Object.keys(config.sorting).find((key) => {\n      if (indexName.endsWith(key)) {\n        return true\n      }\n    })\n\n    if (selectedSorting) {\n      return indexName.replace(selectedSorting, '')\n    }\n  }\n  return indexName\n}\n","import { getSnippetFieldLength } from './transformRequest'\nimport type { ElasticsearchHit, SearchSettingsConfig } from './types'\n\nexport function highlightTerm(value: string, query: string): string {\n  const regex = new RegExp(query, 'gi')\n  return value.replace(regex, (match) => `<em>${match}</em>`)\n}\n\nexport function isAllowableHighlightField(\n  fieldKey: string,\n  highlightFields: string[]\n) {\n  return highlightFields.findIndex((highlightField) => {\n    if (highlightField.indexOf('*') < 0) {\n      return highlightField === fieldKey;\n    }\n\n    const safeHighlightField = highlightField.replace(/[.+?^$|\\{\\}\\(\\)\\[\\]\\\\]/g, '\\\\$&');\n    const regex = new RegExp(`^${safeHighlightField.replace(/\\*/g, '.*')}$`);\n    return regex.test(fieldKey);\n  }) >= 0;\n}\n\nexport function getHighlightFields(\n  hit: ElasticsearchHit,\n  preTag: string = '<ais-highlight-0000000000>',\n  postTag: string = '<ais-highlight-0000000000/>',\n  fields: SearchSettingsConfig['snippet_attributes'] = []\n) {\n  const { _source = {}, highlight = {} } = hit\n\n  const combinedKeys = {\n    ..._source,\n    ...highlight\n  }\n\n  const highlightFields = fields.map((field) => getSnippetFieldLength(field).attribute)\n\n  const hitHighlights = Object.keys(combinedKeys).reduce<Record<string, any>>((sum, fieldKey) => {\n    const fieldValue: any = _source[fieldKey]\n    const highlightedMatch = highlight[fieldKey] || null\n\n    if (!isAllowableHighlightField(fieldKey, highlightFields)) {\n      return sum\n    }\n    // no matches, specified as a highlight and value is an array\n    if (Array.isArray(fieldValue) && !highlightedMatch) {\n      return {\n        ...sum,\n        [fieldKey]: fieldValue.map((value) => ({\n          matchLevel: 'none',\n          matchedWords: [],\n          value: value.toString()\n        }))\n      }\n      // field array and has multiple highlighted matches\n    } else if (Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch)) {\n      return {\n        ...sum,\n        [fieldKey]: highlightedMatch.map((highlightedMatch) => {\n          const matchWords = Array.from(highlightedMatch.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(\n            (match) => match[1]\n          )\n          return {\n            fullyHighlighted: false,\n            matchLevel: 'full',\n            matchedWords: matchWords,\n            value: highlightedMatch\n              .toString()\n              .replace(/\\<em\\>/g, preTag)\n              .replace(/\\<\\/em\\>/g, postTag)\n          }\n        })\n      }\n    } else if (\n      (!Array.isArray(fieldValue) && highlightedMatch && Array.isArray(highlightedMatch)) ||\n      (!fieldValue && Array.isArray(highlightedMatch) && highlightedMatch.length > 0)\n    ) {\n      const singleMatch = highlightedMatch[0]\n\n      const matchWords = Array.from(singleMatch.matchAll(/\\<em\\>(.*?)\\<\\/em\\>/g)).map(\n        (match) => match[1]\n      )\n      const x = {\n        fullyHighlighted: false,\n        matchLevel: 'full',\n        matchedWords: matchWords,\n        value: singleMatch\n          .toString()\n          .replace(/\\<em\\>/g, preTag)\n          .replace(/\\<\\/em\\>/g, postTag)\n      }\n\n      return {\n        ...sum,\n        [fieldKey]: x\n      }\n    }\n\n    return {\n      ...sum,\n      [fieldKey]: {\n        matchLevel: 'none',\n        matchedWords: [],\n        value: fieldValue != undefined ? fieldValue.toString() : ''\n      }\n    }\n  }, {})\n\n  return hitHighlights\n}\n","import { SearchSettingsConfig } from './types'\nimport { getHighlightFields, highlightTerm } from './highlightUtils'\nimport { AlgoliaMultipleQueriesQuery, ElasticsearchResponseBody } from './types'\nimport { getFacetFieldType } from './utils'\nimport { QueryRuleActions } from './queryRules'\nimport type { AggregationsStatsAggregate, GeoLocation } from '@elastic/elasticsearch/lib/api/types'\n\ntype FacetsList = Record<string, Record<string, number>>\ntype FacetsStats = Record<\n  string,\n  { min: number | null; max: number | null; avg: number | null; sum: number | null }\n>\n\nconst getHits = (\n  response: ElasticsearchResponseBody,\n  config: SearchSettingsConfig,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery\n) => {\n  const { hits } = response\n  const { highlight_attributes = [], snippet_attributes = [] } = config\n\n  return hits.hits.map((hit) => ({\n    objectID: hit._id,\n    _index: hit?._index,\n    ...(hit._source || {}),\n    ...(hit.inner_hits ? { inner_hits: hit.inner_hits } : {}),\n    ...(highlight_attributes.length > 0\n      ? {\n          _highlightResult: getHighlightFields(\n            hit,\n            instantsearchRequest?.params?.highlightPreTag,\n            instantsearchRequest?.params?.highlightPostTag,\n            highlight_attributes\n          )\n        }\n      : {}),\n    ...(snippet_attributes.length > 0\n      ? {\n          _snippetResult: getHighlightFields(\n            hit,\n            instantsearchRequest?.params?.highlightPreTag,\n            instantsearchRequest?.params?.highlightPostTag,\n            config.snippet_attributes\n          )\n        }\n      : {}),\n    ...(config.geo_attribute && hit._source?.[config.geo_attribute]\n      ? { _geoloc: convertLatLng(hit._source?.[config.geo_attribute] as GeoLocation) }\n      : {})\n  }))\n}\n\nfunction convertLatLng(value: GeoLocation) {\n  if (typeof value === 'string') {\n    const [lat, lng] = value.split(',').map((v) => parseFloat(v))\n    return { lat, lng }\n  } else if (Array.isArray(value)) {\n    return { lat: value[0], lng: value[1] }\n  } else if (typeof value === 'object') {\n    if ('lat' in value && 'lon' in value) {\n      return {\n        lat: parseFloat(value.lat as unknown as string),\n        lng: parseFloat(value.lon as unknown as string)\n      }\n    }\n  }\n  return null\n}\n\nconst getFacets = (response: ElasticsearchResponseBody, config: SearchSettingsConfig) => {\n  if (!response?.aggregations) {\n    return {}\n  }\n\n  // flattening for nested facets\n  const aggregations = Object.keys(response.aggregations).reduce<Record<string, any>>(\n    (sum, key) => {\n      const value = (response.aggregations || {})[key] as any\n\n      if (key.endsWith('.')) {\n        const { doc_count, ...nestedAggregations } = value\n        return {\n          ...sum,\n          ...nestedAggregations\n        }\n      }\n\n      return {\n        ...sum,\n        [key]: value\n      }\n    },\n    {}\n  )\n\n  return Object.keys(aggregations).reduce<{\n    facets: FacetsList\n    facets_stats: FacetsStats\n  }>(\n    (sum, f) => {\n      const facet = f.split('$')[0]\n      const fieldType = getFacetFieldType(config.facet_attributes || [], facet)\n\n      if (fieldType === 'numeric') {\n        const facetValues = aggregations[facet + '$_stats'] as AggregationsStatsAggregate\n        const { buckets } = aggregations[facet + '$_entries'] as {\n          buckets: any[]\n        }\n\n        return {\n          ...sum,\n          facets: {\n            ...sum.facets,\n            [facet]: buckets.reduce<Record<string, number>>(\n              (sum, bucket) => ({\n                ...sum,\n                [bucket.key]: bucket.doc_count\n              }),\n              {}\n            )\n          },\n          facets_stats: {\n            ...sum.facets_stats,\n            [facet]: {\n              min: facetValues.min,\n              avg: facetValues.avg,\n              max: facetValues.max,\n              sum: facetValues.sum\n            }\n          }\n        }\n      }\n\n      const { buckets } = aggregations[facet] as { buckets: any[] }\n\n      return {\n        ...sum,\n        facets: {\n          ...sum.facets,\n          [facet]: buckets.reduce<Record<string, number>>(\n            (sum, bucket) => ({\n              ...sum,\n              [bucket.key]: bucket.doc_count\n            }),\n            {}\n          )\n        }\n      }\n    },\n    {\n      facets: {},\n      facets_stats: {}\n    }\n  )\n}\n\nconst getRenderingContent = (config: SearchSettingsConfig, queryRuleActions: QueryRuleActions) => {\n  const defaultOrder = config.facet_attributes?.map((facet) =>\n    typeof facet === 'string' ? facet : facet.attribute\n  )\n\n  return {\n    renderingContent: {\n      facetOrdering: {\n        facets: {\n          order: queryRuleActions.facetAttributesOrder || defaultOrder || []\n        },\n        values: config.facet_attributes?.reduce<Record<string, { sortRemainingBy: 'count' }>>(\n          (sum, facet) => {\n            const facetName = typeof facet === 'string' ? facet : facet.attribute\n\n            // If request has explicit facet orders and the facet is not\n            // in the query rule actions, we don't want to sort it\n            if (\n              queryRuleActions.facetAttributesOrder &&\n              !queryRuleActions.facetAttributesOrder.includes(facetName)\n            ) {\n              return sum\n            }\n\n            return {\n              ...sum,\n              [facetName]: {\n                sortRemainingBy: 'count'\n              }\n            }\n          },\n          {}\n        )\n      }\n    }\n  }\n}\n\nconst getPageDetails = (\n  response: ElasticsearchResponseBody,\n  request: AlgoliaMultipleQueriesQuery,\n  queryRuleActions: QueryRuleActions\n) => {\n  const { params = {} } = request\n  const { hitsPerPage = 20, page = 0 } = params\n\n  const { total } = response.hits\n  const totalHits = typeof total === 'number' ? total : total?.value\n  const nbPages =\n    hitsPerPage <= 0\n      ? 0\n      : Math.ceil((typeof total === 'number' ? total : total?.value || 0) / hitsPerPage)\n\n  return {\n    hitsPerPage,\n    processingTimeMS: response.took,\n    nbHits: totalHits,\n    page: page,\n    nbPages,\n    query: queryRuleActions.query\n  }\n}\n\nexport default function transformResponse(\n  response: ElasticsearchResponseBody,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig,\n  queryRuleActions: QueryRuleActions\n) {\n  try {\n    return {\n      appliedRules: queryRuleActions.ruleIds,\n      exhaustiveNbHits: true,\n      exhaustiveFacetsCount: true,\n      exhaustiveTypo: true,\n      exhaustive: { facetsCount: true, nbHits: true, typo: true },\n      ...getPageDetails(response, instantsearchRequest, queryRuleActions),\n      ...getRenderingContent(config, queryRuleActions),\n      ...getFacets(response, config),\n      hits: getHits(response, config, instantsearchRequest),\n      index: instantsearchRequest.indexName,\n      params: new URLSearchParams(instantsearchRequest.params as any).toString(),\n      ...(queryRuleActions.userData.length > 0 ? { userData: queryRuleActions.userData } : {})\n    }\n  } catch (e) {\n    throw new Error(`Error transforming Elasticsearch response for index`)\n  }\n}\n\nexport const transformFacetValuesResponse = (\n  response: ElasticsearchResponseBody,\n  instantsearchRequest: AlgoliaMultipleQueriesQuery\n) => {\n  const aggregations = response.aggregations || {}\n  // @ts-ignore\n  const facetName = instantsearchRequest?.params?.facetName\n\n  const preTag = instantsearchRequest.params?.highlightPreTag || '<ais-highlight-0000000000>'\n  const postTag = instantsearchRequest.params?.highlightPostTag || '<ais-highlight-0000000000/>'\n\n  let agg = aggregations[Object.keys(aggregations)[0]] as any\n\n  if (agg && agg[facetName]) {\n    agg = agg[facetName]\n  }\n\n  return {\n    facetHits: agg.buckets.map((entry: any) => ({\n      value: entry.key,\n      highlighted: highlightTerm(\n        entry.key,\n        // @ts-ignore\n        instantsearchRequest.params.facetQuery || ''\n      )\n        .replace(/<\\em>/g, preTag)\n        .replace(/<\\/\\em>/g, postTag),\n      count: entry.doc_count\n    })),\n    exhaustiveFacetsCount: true,\n    processingTimeMS: response.took\n  }\n}\n","import { AppSettings, BasicAuth, ConfigConnection, SearchRequest } from './types'\nimport { ElasticsearchResponseBody, Transporter } from './types'\nimport { createElasticsearchQueryFromRequest } from './utils'\n\nconst authString = (auth: BasicAuth) => {\n  if (typeof btoa === 'undefined') {\n    return Buffer.from(auth.username + ':' + auth.password).toString('base64')\n  } else {\n    return btoa(auth.username + ':' + auth.password)\n  }\n}\n\nexport class ESTransporter implements Transporter {\n  constructor(public config: ConfigConnection, private settings: AppSettings) {}\n\n  createElasticsearchQueryFromRequest(requests: SearchRequest[]) {\n    return createElasticsearchQueryFromRequest(requests)\n  }\n\n  async performNetworkRequest(requests: SearchRequest[]) {\n    return fetch(`${this.config.host}/_msearch`, {\n      headers: {\n        ...(this.config.apiKey ? { authorization: `ApiKey ${this.config.apiKey}` } : {}),\n        'content-type': 'application/json',\n        ...(this.config.headers || {}),\n        ...(this.config.auth\n          ? {\n              Authorization: 'Basic ' + authString(this.config.auth)\n            }\n          : {})\n      },\n      body: this.createElasticsearchQueryFromRequest(requests),\n      method: 'POST'\n    })\n  }\n\n  async msearch(requests: SearchRequest[]): Promise<ElasticsearchResponseBody[]> {\n    try {\n      const response = await this.performNetworkRequest(requests)\n      const responses = await response.json()\n\n      if (this.settings.debug) {\n        console.log('Elasticsearch response:')\n        console.log(JSON.stringify(responses))\n      }\n\n      if (responses.status >= 500) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Elasticsearch Internal Error: Check your elasticsearch instance to make sure it can recieve requests.'\n        )\n      } else if (responses.status === 401) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Cannot connect to Elasticsearch. Check your connection host and auth details (username/password or API Key required). You can also provide a custom Elasticsearch transporter to the API Client. See https://www.searchkit.co/docs/guides/setup-elasticsearch#connecting-with-usernamepassword for more details.'\n        )\n      } else if (responses.responses?.[0]?.status === 403) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Auth Error: You do not have permission to access this index. Check you are calling the right index (specified in frontend) and your API Key permissions has access to the index.'\n        )\n      } else if (responses.status === 404 || responses.responses?.[0]?.status === 404) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          'Elasticsearch index not found. Check your index name and make sure it exists.'\n        )\n      } else if (responses.status === 400 || responses.responses?.[0]?.status === 400) {\n        console.error(JSON.stringify(responses))\n        throw new Error(\n          `Elasticsearch Bad Request. \n          \n          1. Check your query and make sure it is valid. \n          2. Check the field mapping. See documentation to make sure you are using text types for searching and keyword fields for faceting\n          3. Turn on debug mode to see the Elasticsearch query and the error response.\n          `\n        )\n      }\n      return responses.responses\n    } catch (error) {\n      throw error\n    }\n  }\n}\n","import { transformQueryString } from './filters'\nimport { AlgoliaMultipleQueriesQuery, QueryRule, SearchSettingsConfig } from './types'\n\nexport interface QueryContextFilter {\n  attribute: string\n  value: string\n}\n\nexport interface QueryContext {\n  query: string\n  context: readonly string[]\n  filters: readonly QueryContextFilter[]\n}\n\nexport interface QueryRuleActions {\n  ruleIds: string[]\n  pinnedDocs: string[]\n  boostFunctions: any[]\n  query: string\n  userData: unknown[]\n  facetAttributesOrder: string[] | undefined\n  baseFilters: any[]\n  touched: boolean\n}\n\nconst getFacetFilters = (\n  facetFilters: string | readonly string[] | readonly (string | readonly string[])[] | undefined\n): QueryContextFilter[] => {\n  if (!facetFilters) {\n    return []\n  }\n  if (typeof facetFilters === 'string') {\n    const [attribute, value] = facetFilters.split(':')\n    return [{ attribute, value }]\n  } else {\n    // @ts-ignore\n    return facetFilters.reduce<QueryContextFilter[]>((sum: any, filter: any) => {\n      if (typeof filter === 'string') {\n        const [attribute, value] = filter.split(':')\n        return [...sum, { attribute, value }]\n      }\n      return [...sum, ...getFacetFilters(filter)]\n    }, [])\n  }\n}\n\nexport const getQueryRulesActionsFromRequest = (\n  queryRules: QueryRule[],\n  request: AlgoliaMultipleQueriesQuery,\n  config: SearchSettingsConfig\n) => {\n  const queryContext: QueryContext = {\n    query: request.params?.query || '',\n    context: request.params?.ruleContexts || [],\n    filters: getFacetFilters(request.params?.facetFilters)\n  }\n\n  const satisfiedRules = getSatisfiedRules(queryContext, queryRules || [])\n\n  const actions = satisfiedRules.reduce<QueryRuleActions>(\n    (sum, rule) => {\n      rule.actions.map((action) => {\n        sum.touched = true\n        if (action.action === 'PinnedResult') {\n          sum.pinnedDocs.push(...action.documentIds)\n        } else if (action.action === 'QueryRewrite') {\n          sum.query = action.query\n        } else if (action.action === 'QueryBoost') {\n          sum.boostFunctions.push({\n            filter: {\n              query_string: {\n                query: transformQueryString(\n                  config.facet_attributes,\n                  config.filter_attributes,\n                  action.query\n                )\n              }\n            },\n            weight: action.weight\n          })\n        } else if (action.action === 'RenderUserData') {\n          sum.userData.push(JSON.parse(action.userData))\n        } else if (action.action === 'RenderFacetsOrder') {\n          sum.facetAttributesOrder = action.facetAttributesOrder\n        } else if (action.action === 'QueryFilter') {\n          sum.baseFilters.push({\n            query_string: {\n              query: transformQueryString(\n                config.facet_attributes,\n                config.filter_attributes,\n                action.query\n              )\n            }\n          })\n        }\n      })\n      return sum\n    },\n    {\n      ruleIds: satisfiedRules.map((rule) => rule.id),\n      pinnedDocs: [],\n      boostFunctions: [],\n      query: queryContext.query,\n      userData: [],\n      facetAttributesOrder: undefined,\n      touched: false,\n      baseFilters: []\n    }\n  )\n\n  return actions\n}\n\nexport const getSatisfiedRules = (queryContext: QueryContext, rules: QueryRule[]) =>\n  rules.filter(\n    (ruleOrs) =>\n      ruleOrs.conditions.find(\n        (rule) =>\n          rule.filter((condition) => {\n            if (condition.context === 'query' && condition.match_type === 'exact') {\n              return condition.value === queryContext.query\n            }\n            if (condition.context === 'query' && condition.match_type === 'contains') {\n              return queryContext.query.includes(condition.value)\n            }\n            if (condition.context === 'query' && condition.match_type === 'prefix') {\n              return queryContext.query.startsWith(condition.value)\n            }\n            if (condition.context === 'context') {\n              return condition.value.some((value) => queryContext.context.includes(value))\n            }\n            if (condition.context === 'filterPresent') {\n              return condition.values.every(\n                (value) =>\n                  queryContext.filters.find(\n                    (filter) => filter.attribute === value.attribute && filter.value === value.value\n                  ) !== undefined\n              )\n            }\n\n            return false\n          }).length === rule.length\n      ) !== undefined\n  )\n"],"mappings":"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","names":["require_cjs","__commonJSMin","exports","module","isMergeableObject","value","isNonNullObject","isSpecial","stringValue","isReactElement","canUseSymbol","REACT_ELEMENT_TYPE","emptyTarget","val","cloneUnlessOtherwiseSpecified","options","deepmerge","defaultArrayMerge","target","source","element","getMergeFunction","key","customMerge","getEnumerableOwnPropertySymbols","symbol","getKeys","propertyIsOnObject","object","property","propertyIsUnsafe","mergeObject","destination","sourceIsArray","targetIsArray","sourceAndTargetTypesMatch","array","prev","next","deepmerge_1","src_exports","__export","ESTransporter","MatchFilter","TermFilter","Searchkit","import_deepmerge","TermFilter","field","value","MatchFilter","getFacet","facet_attributes","attributeName","a","isNestedFacet","facet","getFacetFieldType","facet_attributes","attribute","_a","attributeKey","a","createElasticsearchQueryFromRequest","requests","sum","request","transformNumericFilters","request","config","params","numericFilters","sum","filter","match","field","operator","value","maxValue","groups","facetFilterConfig","getFacetFilterMap","getFilter","esFilter","nestedPathPresent","facets","filters","f","transformFacetFilters","facetFilters","facetFilterMap","facet","filterClauseFn","TermFilter","isNestedFacet","nestedFilter","transformQueryString","queryString","regex","filterMap","word","transformBaseFilters","transformGeoFilters","aroundLatLng","aroundRadius","insideBoundingBox","insideBoundingBoxFilter","geoPoint","geoBoundingboxFilter","top","left","bottom","right","boundingBox","getSorting","request","config","selectedSorting","key","sortOption","sorting","getIndexName","indexName","createRegexQuery","queryString","query","char","TermAggregation","field","size","search","searchInclude","getTermAggregation","facet","aggEntries","AggregationFn","getInnerAggs","facetName","isNestedFacet","getAggs","request","config","queryRuleActions","params","type","facets","maxValuesPerFacet","facetQuery","maxFacetSize","facetAttributes","getFacet","facetAttibutes","attribute","x","facetAttribute","sum","deepmerge","queryRulesWrapper","organicQuery","RelevanceQueryMatch","search_attributes","getFieldsMap","boostMultiplier","getQuery","requestOptions","_a","_b","_c","searchAttributes","filters","transformFacetFilters","transformNumericFilters","transformBaseFilters","transformGeoFilters","hasKnn","hasNoQuery","queryDsl","knnQueryDsl","getResultsSize","hitsPerPage","getHitFields","attributesToRetrieve","sourceFields","getSnippetFieldLength","defaultMatch","match","getHighlightFields","attributesToHighlight","highlightFields","snippetFields","transformRequest","getSorting","highlightTerm","value","query","regex","match","isAllowableHighlightField","fieldKey","highlightFields","highlightField","safeHighlightField","getHighlightFields","hit","preTag","postTag","fields","_source","highlight","combinedKeys","field","getSnippetFieldLength","sum","fieldValue","highlightedMatch","singleMatch","x","getHits","response","config","instantsearchRequest","hits","highlight_attributes","snippet_attributes","hit","_a","_b","_c","_d","_e","_f","getHighlightFields","convertLatLng","value","lat","lng","v","getFacets","aggregations","sum","key","doc_count","nestedAggregations","f","facet","getFacetFieldType","facetValues","buckets","bucket","getRenderingContent","queryRuleActions","defaultOrder","facetName","getPageDetails","request","params","hitsPerPage","page","total","totalHits","nbPages","transformResponse","transformFacetValuesResponse","preTag","postTag","agg","entry","highlightTerm","authString","auth","ESTransporter","config","settings","requests","createElasticsearchQueryFromRequest","_a","_b","_c","_d","_e","_f","responses","error","getFacetFilters","facetFilters","attribute","value","sum","filter","getQueryRulesActionsFromRequest","queryRules","request","config","_a","_b","_c","queryContext","satisfiedRules","getSatisfiedRules","rule","action","transformQueryString","rules","ruleOrs","condition","Searchkit","config","settings","ESTransporter","requests","createElasticsearchQueryFromRequest","err","instantsearchRequests","requestOptions","_a","_b","queryRules","requestQueryRuleActions","request","getQueryRulesActionsFromRequest","esRequests","i","transformRequest","getIndexName","esResponses","response","transformFacetValuesResponse","transformResponse"]}